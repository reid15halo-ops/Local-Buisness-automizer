#!/usr/bin/env node
/**
 * build-sw.js — Generate service-worker.js with a build-time cache version.
 *
 * Usage:
 *   node build-sw.js            → production  cache: freyai-visions-{hash}
 *   STAGING=true node build-sw.js → staging  cache: freyai-staging-{hash}
 *
 * The hash is derived from the current git commit SHA (first 8 chars) plus a
 * Unix timestamp so each deploy gets a unique cache bucket. This guarantees
 * users receive fresh assets without manually bumping a version number.
 */

'use strict';

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const ROOT = __dirname;
const SW_TEMPLATE = path.join(ROOT, 'service-worker.js');

// ── Derive build hash ──────────────────────────────────────────────────────
let gitHash = 'local';
try {
    gitHash = execSync('git rev-parse --short=8 HEAD', { cwd: ROOT, stdio: ['ignore', 'pipe', 'ignore'] })
        .toString()
        .trim();
} catch {
    // Not a git repo or git not installed — fall back to timestamp
}

const buildId = `${gitHash}-${Math.floor(Date.now() / 1000)}`;
const isStaging = process.env.STAGING === 'true' || process.env.STAGING === '1';
const cachePrefix = isStaging ? 'freyai-staging' : 'freyai-visions';
const cacheName = `${cachePrefix}-${buildId}`;

// ── Patch the cache name in service-worker.js ─────────────────────────────
const swContent = fs.readFileSync(SW_TEMPLATE, 'utf8');

const patched = swContent.replace(
    /^const CACHE_NAME\s*=\s*['"][^'"]*['"];/m,
    `const CACHE_NAME = '${cacheName}'; // generated by build-sw.js`
);

if (patched === swContent) {
    console.error('❌  Could not find CACHE_NAME in service-worker.js — no changes written.');
    process.exit(1);
}

fs.writeFileSync(SW_TEMPLATE, patched, 'utf8');

console.log(`✅  Cache name updated: ${cacheName}`);
console.log(`    Mode    : ${isStaging ? 'STAGING' : 'production'}`);
console.log(`    Git SHA : ${gitHash}`);
console.log(`    Build ID: ${buildId}`);
